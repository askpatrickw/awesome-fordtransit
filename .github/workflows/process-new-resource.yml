name: Process New Resource

on:
  issues:
    types: [opened]

permissions:
  contents: read
  issues: write
  models: read
  pull-requests: write

jobs:
  process-resource:
    if: contains(join(github.event.issue.labels.*.name, ','), 'new-resource')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 pyyaml
          gh extension install github/gh-models
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse issue body
        id: parse
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          python3 - <<EOF
          import re
          import os

          issue_body = os.environ["ISSUE_BODY"]

          def extract(pattern):
              match = re.search(pattern, issue_body, re.MULTILINE | re.DOTALL)
              return match.group(1).strip() if match else ""

          url = extract(r'### URL\s*\n\s*(.+)')
          use_ai = "- [x] Use AI to generate description and category" in issue_body
          manual_desc = extract(r'### Description \(Optional if using AI\)\s*\n\s*(.+)')
          manual_cat = extract(r'### Category \(Optional if using AI\)\s*\n\s*(.+)')
          override = extract(r'### Override AI Suggestion \(Optional\)\s*\n\s*(.+)')

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"url={url}\n")
              f.write(f"use_ai={use_ai}\n")
              f.write(f"manual_desc={manual_desc}\n")
              f.write(f"manual_cat={manual_cat}\n")
              f.write(f"override={override}\n")
          EOF

      - name: Validate URL
        id: validate
        run: |
          python3 .github/scripts/validate_url.py "${{ steps.parse.outputs.url }}"
        continue-on-error: true

      - name: Check for duplicates
        id: duplicates
        run: |
          python3 .github/scripts/check_duplicates.py "${{ steps.parse.outputs.url }}"
        continue-on-error: true

      - name: Generate with AI (if requested)
        id: ai_generate
        if: steps.parse.outputs.use_ai == 'True' && steps.validate.outcome == 'success'
        run: |
          URL="${{ steps.parse.outputs.url }}"

          CONTENT=$(curl -sL "$URL" | head -c 10000)

          DESCRIPTION=$(gh models run openai/gpt-4o-mini "Analyze this Ford Transit website and provide a ONE-LINE description (max 100 chars): $URL" | tr '\n' ' ')
          CATEGORY=$(gh models run openai/gpt-4o-mini "Categorize this Ford Transit resource ($URL) into ONE category..." | tr '\n' ' ')
          APPROPRIATE=$(gh models run openai/gpt-4o-mini "Is this website appropriate for a Ford Transit community resource list?..." | tr '\n' ' ')

          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "category=$CATEGORY" >> $GITHUB_OUTPUT
          echo "appropriate=$APPROPRIATE" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Format entry and update README
        id: format
        run: |
          if [ "${{ steps.parse.outputs.use_ai }}" == "True" ]; then
            DESC="${{ steps.ai_generate.outputs.description }}"
            CAT="${{ steps.ai_generate.outputs.category }}"
          else
            DESC="${{ steps.parse.outputs.manual_desc }}"
            CAT="${{ steps.parse.outputs.manual_cat }}"
          fi

          URL="${{ steps.parse.outputs.url }}"

          ENTRY_LINE=$(gh models run openai/gpt-4o-mini "Create a markdown list entry for: URL=$URL, Description=$DESC..." | tr '\n' ' ')

          README_HEADERS=$(grep '^##' README.md)

          SECTION_HEADER=$(gh models run openai/gpt-4o-mini "Find the exact section header that matches category '$CAT'..." | tr '\n' ' ')

          if [ -z "$SECTION_HEADER" ] || [[ ! "$SECTION_HEADER" =~ ^##.* ]]; then
            echo "AI section detection failed, using fuzzy matching fallback"
            SECTION_HEADER=$(echo "$README_HEADERS" | grep -i "$CAT" | head -n1)
            if [ -z "$SECTION_HEADER" ]; then
              SECTION_HEADER="## $CAT"
              echo "Creating new section: $SECTION_HEADER"
            fi
          fi

          SECTION_START=$(grep -n "^$(echo "$SECTION_HEADER" | sed 's/[[\.*^$()+?{|]/\\&/g')" README.md | head -n1 | cut -d: -f1)
          if [ -z "$SECTION_START" ]; then
            echo "Error: Could not find section '$SECTION_HEADER' in README"
            exit 1
          fi

          SECTION_END=$(tail -n +$((SECTION_START+1)) README.md | grep -n "^##" | head -n1 | cut -d: -f1)
          if [ -n "$SECTION_END" ]; then
            SECTION_END=$((SECTION_START + SECTION_END))
          else
            SECTION_END=$(wc -l < README.md)
          fi

          SECTION_CONTENT=$(sed -n "${SECTION_START},$((SECTION_END-1))p" README.md)

          UPDATED_SECTION=$(gh models run openai/gpt-4o-mini "Add this entry alphabetically: '$ENTRY_LINE'. Current section: '$SECTION_CONTENT'..." | tr '\n' ' ')

          head -n $((SECTION_START-1)) README.md > temp_readme.md
          echo "$UPDATED_SECTION" >> temp_readme.md
          tail -n +$SECTION_END README.md >> temp_readme.md
          mv temp_readme.md README.md

          echo "entry<<EOF" >> $GITHUB_OUTPUT
          echo "$ENTRY_LINE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.parse.outputs.url }}';
            const useAi = '${{ steps.parse.outputs.use_ai }}' === 'True';
            const validated = '${{ steps.validate.outcome }}' === 'success';
            const isDuplicate = '${{ steps.duplicates.outcome }}' === 'failure';
            const description = useAi ? '${{ steps.ai_generate.outputs.description }}' : '${{ steps.parse.outputs.manual_desc }}';
            const category = useAi ? '${{ steps.ai_generate.outputs.category }}' : '${{ steps.parse.outputs.manual_cat }}';
            const appropriate = '${{ steps.ai_generate.outputs.appropriate }}';
            const formattedEntry = `${{ steps.format.outputs.entry }}`;
            const override = '${{ steps.parse.outputs.override }}';

            let comment = '## ü§ñ Automated Analysis Results\n\n';

            if (!validated) {
              comment += '‚ùå **URL Validation Failed**: The provided URL could not be accessed.\n\n';
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, labels: ['invalid-url'] });
              return;
            } else {
              comment += '‚úÖ **URL Validation**: Successful\n';
            }

            if (isDuplicate) {
              comment += '‚ö†Ô∏è **Duplicate Check**: This URL may already exist in the list.\n\n';
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, labels: ['duplicate'] });
            } else {
              comment += '‚úÖ **Duplicate Check**: No duplicates found\n';
            }

            if (useAi && appropriate) {
              if (appropriate.toUpperCase().startsWith('YES')) {
                comment += '‚úÖ **Content Check**: Appropriate for Ford Transit community\n';
              } else {
                comment += `‚ö†Ô∏è **Content Check**: ${appropriate}\n`;
              }
            }

            comment += '\n### üìù Proposed Entry\n\n';
            comment += '**Category**: ' + category + '\n';
            comment += '**Description**: ' + description + '\n\n';
            comment += '```markdown\n' + formattedEntry + '\n```\n\n';

            if (override) {
              comment += '### üí° User Suggestion\n' + override + '\n\n';
            }

            comment += '### ‚è≠Ô∏è Next Steps\n\n';
            comment += '1. Review the proposed entry above\n';
            comment += '2. If it looks good, add the `approved` label to create a PR\n';
            comment += '3. If changes are needed, add the `needs-changes` label and comment with feedback\n';

            await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, body: comment });
            await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number, labels: ['needs-review'] });

      - name: Create Pull Request
        if: steps.validate.outcome == 'success' && steps.duplicates.outcome == 'success'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          BRANCH_NAME="add-resource-$(date +%s)"
          git checkout -b "$BRANCH_NAME"
          git add README.md
          git commit -m "Add new Ford Transit resource from issue #${{ github.event.issue.number }}

          ${{ steps.format.outputs.entry }}

          ü§ñ Generated with GitHub Actions"

          git push origin "$BRANCH_NAME"

          DESC="${{ steps.ai_generate.outputs.description }}"
          [ -z "$DESC" ] && DESC="${{ steps.parse.outputs.manual_desc }}"
          CAT="${{ steps.ai_generate.outputs.category }}"
          [ -z "$CAT" ] && CAT="${{ steps.parse.outputs.manual_cat }}"

          PR_BODY="Resolves #${{ github.event.issue.number }}

          ## Summary
          - Added new Ford Transit resource to **$CAT** section
          - Entry: \`${{ steps.format.outputs.entry }}\`

          ## Validation Results
          - ‚úÖ URL accessible
          - ‚úÖ No duplicates found
          "

          if [[ "${{ steps.ai_generate.outputs.appropriate }}" =~ ^YES ]]; then
            PR_BODY+="\n- ‚úÖ Content appropriate"
          fi

          echo "$PR_BODY" > pr_body.md

          gh pr create \
            --title "Add Ford Transit resource: $DESC" \
            --body-file pr_body.md \
            --label "new-resource"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
