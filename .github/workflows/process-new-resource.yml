name: Process New Resource

on:
  issues:
    types: [opened]

permissions:
  contents: read
  issues: write
  models: read
  pull-requests: write

jobs:
  process-resource:
    if: contains(github.event.issue.labels.*.name, 'new-resource')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 pyyaml
          gh extension install github/gh-models
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse issue body
        id: parse
        run: |
          python3 - <<'EOF'
          import re
          import yaml
          import json
          import os

          issue_body = """${{ github.event.issue.body }}"""

          # Extract URL
          url_match = re.search(r'### URL\s*\n\s*(.+)', issue_body)
          url = url_match.group(1).strip() if url_match else ""

          # Check if AI generation is requested
          use_ai = "- [x] Use AI to generate description and category" in issue_body

          # Extract manual description if provided
          desc_match = re.search(r'### Description \(Optional if using AI\)\s*\n\s*(.+)', issue_body)
          manual_desc = desc_match.group(1).strip() if desc_match else ""

          # Extract manual category if provided
          cat_match = re.search(r'### Category \(Optional if using AI\)\s*\n\s*(.+)', issue_body)
          manual_cat = cat_match.group(1).strip() if cat_match else ""

          # Extract override suggestion
          override_match = re.search(r'### Override AI Suggestion \(Optional\)\s*\n\s*(.+)', issue_body, re.MULTILINE | re.DOTALL)
          override = override_match.group(1).strip() if override_match else ""

          # Set outputs
          print(f"url={url}")
          print(f"use_ai={use_ai}")
          print(f"manual_desc={manual_desc}")
          print(f"manual_cat={manual_cat}")
          print(f"override={override}")

          # Write to GITHUB_OUTPUT
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"url={url}\n")
              f.write(f"use_ai={use_ai}\n")
              f.write(f"manual_desc={manual_desc}\n")
              f.write(f"manual_cat={manual_cat}\n")
              f.write(f"override={override}\n")
          EOF

      - name: Validate URL
        id: validate
        run: |
          python3 .github/scripts/validate_url.py "${{ steps.parse.outputs.url }}"
        continue-on-error: true

      - name: Check for duplicates
        id: duplicates
        run: |
          python3 .github/scripts/check_duplicates.py "${{ steps.parse.outputs.url }}"
        continue-on-error: true

      - name: Generate with AI (if requested)
        id: ai_generate
        if: steps.parse.outputs.use_ai == 'True' && steps.validate.outcome == 'success'
        run: |
          URL="${{ steps.parse.outputs.url }}"

          # Fetch page content
          CONTENT=$(curl -sL "$URL" | head -c 10000)

          # Generate description
          DESCRIPTION=$(gh models run openai/gpt-4o-mini "Analyze this Ford Transit website and provide a ONE-LINE description (max 100 chars): $URL. Brief description format like 'Bumpers, skid plates, and lift kits for Ford Transit'")

          # Determine category
          CATEGORY=$(gh models run openai/gpt-4o-mini "Categorize this Ford Transit resource ($URL) into ONE category: Community, Dealers, Engine Mods, Exterior, Exterior - Bumpers, Exterior - Front Hooks, Exterior - Rear Shock Relocation, Exterior - Skid Plates, Exterior - Ski Boxes, Heating and AC, Interior, Maintenance, Plumbing, Suppliers, Suspension and Lifts, Seat Swivels, Van Automation, Van Builds, Van Builders, Wheels and Tires. Return ONLY the category name.")

          # Check for appropriate content
          APPROPRIATE=$(gh models run openai/gpt-4o-mini "Is this website appropriate for a Ford Transit community resource list? Check $URL for: Transit-related content, no inappropriate content, legitimate business. Reply with only YES or NO and brief reason.")

          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "category=$CATEGORY" >> $GITHUB_OUTPUT
          echo "appropriate=$APPROPRIATE" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Format entry and update README
        id: format
        run: |
          if [ "${{ steps.parse.outputs.use_ai }}" == "True" ]; then
            DESC="${{ steps.ai_generate.outputs.description }}"
            CAT="${{ steps.ai_generate.outputs.category }}"
          else
            DESC="${{ steps.parse.outputs.manual_desc }}"
            CAT="${{ steps.parse.outputs.manual_cat }}"
          fi

          URL="${{ steps.parse.outputs.url }}"

          # Create formatted entry using AI
          ENTRY_LINE=$(gh models run openai/gpt-4o-mini "Create a markdown list entry for: URL=$URL, Description=$DESC. Format: '- [Site Name](url) Description'. Extract site name from URL domain.")

          # Dynamically find the section header using AI
          README_HEADERS=$(grep '^##' README.md)

          SECTION_HEADER=$(gh models run openai/gpt-4o-mini "Find the exact section header that matches category '$CAT'. Available headers: $README_HEADERS. Rules: 1) Match to most appropriate section 2) For subcategories like 'Exterior - Bumpers' match to '### Bumpers' 3) Return ONLY the exact header text with ## or ###. Examples: 'Van Builds' ‚Üí '## Van Builds', 'Exterior - Bumpers' ‚Üí '### Bumpers', 'Heating and AC' ‚Üí '## Heating and Air Conditioning'")

          # Fallback: if AI response is empty or invalid, try fuzzy matching
          if [ -z "$SECTION_HEADER" ] || [[ ! "$SECTION_HEADER" =~ ^##.* ]]; then
            echo "AI section detection failed, using fuzzy matching fallback"
            SECTION_HEADER=$(echo "$README_HEADERS" | grep -i "$CAT" | head -n1)

            # Final fallback: create a new section
            if [ -z "$SECTION_HEADER" ]; then
              SECTION_HEADER="## $CAT"
              echo "Creating new section: $SECTION_HEADER"
            fi
          fi

          # Find section boundaries
          SECTION_START=$(grep -n "^$(echo "$SECTION_HEADER" | sed 's/[[\.*^$()+?{|]/\\&/g')" README.md | head -n1 | cut -d: -f1)

          if [ -z "$SECTION_START" ]; then
            echo "Error: Could not find section '$SECTION_HEADER' in README"
            exit 1
          fi

          # Find end of section (next header at same or higher level)
          if [[ "$SECTION_HEADER" == "###"* ]]; then
            # For subsections, find next ### or ## header
            SECTION_END=$(tail -n +$((SECTION_START+1)) README.md | grep -n "^##" | head -n1 | cut -d: -f1)
          else
            # For main sections, find next ## header
            SECTION_END=$(tail -n +$((SECTION_START+1)) README.md | grep -n "^##" | head -n1 | cut -d: -f1)
          fi

          if [ -n "$SECTION_END" ]; then
            SECTION_END=$((SECTION_START + SECTION_END))
          else
            SECTION_END=$(wc -l < README.md)
          fi

          # Extract just the target section
          SECTION_CONTENT=$(sed -n "${SECTION_START},$((SECTION_END-1))p" README.md)

          # Use AI to add entry to just this section
          UPDATED_SECTION=$(gh models run openai/gpt-4o-mini "Add this entry alphabetically: '$ENTRY_LINE'. Current section: '$SECTION_CONTENT'. Instructions: 1) Add entry in alphabetical order within list items 2) Return ONLY updated section content 3) Maintain exact formatting 4) No explanations")

          # Create temporary file with updated content
          head -n $((SECTION_START-1)) README.md > temp_readme.md
          echo "$UPDATED_SECTION" >> temp_readme.md
          tail -n +$SECTION_END README.md >> temp_readme.md
          mv temp_readme.md README.md

          echo "entry<<EOF" >> $GITHUB_OUTPUT
          echo "$ENTRY_LINE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Comment on issue
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.parse.outputs.url }}';
            const useAi = '${{ steps.parse.outputs.use_ai }}' === 'True';
            const validated = '${{ steps.validate.outcome }}' === 'success';
            const isDuplicate = '${{ steps.duplicates.outcome }}' === 'failure';
            const description = useAi ? '${{ steps.ai_generate.outputs.description }}' : '${{ steps.parse.outputs.manual_desc }}';
            const category = useAi ? '${{ steps.ai_generate.outputs.category }}' : '${{ steps.parse.outputs.manual_cat }}';
            const appropriate = '${{ steps.ai_generate.outputs.appropriate }}';
            const formattedEntry = `${{ steps.format.outputs.entry }}`;

            let comment = '## ü§ñ Automated Analysis Results\n\n';

            // URL Validation
            if (!validated) {
              comment += '‚ùå **URL Validation Failed**: The provided URL could not be accessed.\n\n';
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['invalid-url']
              });
              return;
            } else {
              comment += '‚úÖ **URL Validation**: Successful\n';
            }

            // Duplicate Check
            if (isDuplicate) {
              comment += '‚ö†Ô∏è **Duplicate Check**: This URL may already exist in the list.\n\n';
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['duplicate']
              });
            } else {
              comment += '‚úÖ **Duplicate Check**: No duplicates found\n';
            }

            // Content Appropriateness (AI only)
            if (useAi && appropriate) {
              if (appropriate.startsWith('YES')) {
                comment += '‚úÖ **Content Check**: Appropriate for Ford Transit community\n';
              } else {
                comment += `‚ö†Ô∏è **Content Check**: ${appropriate}\n`;
              }
            }

            // Proposed Entry
            comment += '\n### üìù Proposed Entry\n\n';
            comment += '**Category**: ' + category + '\n';
            comment += '**Description**: ' + description + '\n\n';
            comment += '```markdown\n' + formattedEntry + '\n```\n\n';

            // Override suggestion
            const override = '${{ steps.parse.outputs.override }}';
            if (override) {
              comment += '### üí° User Suggestion\n' + override + '\n\n';
            }

            // Next steps
            comment += '### ‚è≠Ô∏è Next Steps\n\n';
            comment += '1. Review the proposed entry above\n';
            comment += '2. If it looks good, add the `approved` label to create a PR\n';
            comment += '3. If changes are needed, add the `needs-changes` label and comment with feedback\n';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

            // Add needs-review label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['needs-review']
            });

      - name: Create Pull Request
        if: steps.validate.outcome == 'success' && steps.duplicates.outcome == 'success'
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Create branch and commit changes
          BRANCH_NAME="add-resource-$(date +%s)"
          git checkout -b "$BRANCH_NAME"
          git add README.md
          git commit -m "Add new Ford Transit resource from issue #${{ github.event.issue.number }}

          ${{ steps.format.outputs.entry }}

          ü§ñ Generated with GitHub Actions"

          # Push branch
          git push origin "$BRANCH_NAME"

          # Create PR
          gh pr create \
            --title "Add Ford Transit resource: ${{ steps.ai_generate.outputs.description || steps.parse.outputs.manual_desc }}" \
            --body "Resolves #${{ github.event.issue.number }}

          ## Summary
          - Added new Ford Transit resource to **${{ steps.ai_generate.outputs.category || steps.parse.outputs.manual_cat }}** section
          - Entry: \`${{ steps.format.outputs.entry }}\`

          ## Validation Results
          - ‚úÖ URL accessible
          - ‚úÖ No duplicates found
          ${{ steps.ai_generate.outputs.appropriate && steps.ai_generate.outputs.appropriate.startsWith('YES') && '- ‚úÖ Content appropriate' || '' }}

          ü§ñ Generated with GitHub Actions" \
            --label "new-resource"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
